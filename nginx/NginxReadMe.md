1. 惊群问题：
在《unix网络编程中》介绍了多进程模式下同时accept()会唤醒所有的工作进程，在Linux2.6版本以后，内核内核已经解决了accept()函数的“惊群”问题。
但在nginx中，每个worker进程不是直接accept，而是使用epoll等机制进行等待，新版本Linux部分的解决了epoll的“惊群”问题。Nginx中使用mutex互斥锁解决这个问题，具体措施有使用全局互斥锁
具体参考：https://mp.weixin.qq.com/s/hSCm-aYw1qmcx7tks-ApUg


判断是否是url的方法是输入到浏览器能够访问, url一定是uri,但uri不一定是url. nginx部分书籍上介绍rewrite等指令接收到的uri指的是host后面的相对路径.
http协议请求包里面，为什么有了URL还需要一个host域:
请求头里的host指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置
但是url可以改写,会出现请求头的host与URL的不一致. 请求头里面第一行是请求行, 请求行GET /login HTTP/1.1, 中间的/login 请求的资源路径
请求头部的信息是根据url的分解生成的.

请求重定向是客户端行为,在接受到3xx响应后浏览器会请求到新的地址,地址栏的url会变. 当然,也需要服务端返回新的重写新的url返回给客户端.
http改为https的请求可以通过重定向实现,参考www.baidu.com.
请求地址转发是服务器行为,地址栏的地址不变,会请求到改写后的资源,发生在同一站点项目内
nginx的rewrite实现的是重定向, location中的alias是转发

nginx配置文件中的$1表示上一个路径中正则表达式匹配的第一个参数。
rewrite regrex replacement
意思是若接收到的uri匹配regrex定义的正则(regrex使用()标记要截取的内容), 就将uri改写为replacement定义的url.
rewrite接收到的是uri不包含host地址,不包含请求,只是相对路径. location接收到的也是不含host,但是含请求参数
rewrite ^(.*) http://jump.myweb.name$1 permanent
$1是(.*) 匹配到的内容,而这里是全匹配, rewrite接收到只是相对路径,所以是对整个域名做了重定向.

临时重定向浏览器不会缓存，永久重定向是浏览器会存储到disk，下次再访问时直接跳转到重定向后的链接，可以减轻服务器压力。
nginx中的return和rewrite语句都可以实现重定向。
rewrite指令后面的flag有四种，其中redirect和permanent是重定向，浏览器会改变地址，last和break是重写，浏览器不会改变地址。
重定向可以转到其他站点的资源上，而重写只能是本站资源，重定向的速度比转发慢
alias是给目录重新命名，即根据后缀去访问对应的目录，与URL重写无关，root是指定顶层目录

nginx的事件驱动:
nginx的web请求是通过事件驱动模型实现的,事件驱动模型的实现需要事件收集器,事件发送器,事件处理器.
事件处理器的的实现: 1.事件发送器每来一个请求,就新建一个进程处理; 2每来一个请求新建一个线程; 3将新的请求
放入待处理事件的队列, 使用非阻塞方式调用.

select库可以关注一个描述符的读事件,写事件和异常事件,要创建3类事件描述符,即使只监听一个描述符的所有事件,
也得创建3个描述符集合. select轮询的时候需要分别轮询这三个集合. 而poll库只需要创建一个集合,在每个描述符对应的
结构上分别设置度事件,写事件和异常事件.最后轮询的时候,可以同时检查这三种事件是否发生.select有1024等上限,poll没有上限.
epoll库是poll的变种,不用再轮询,效率很高. epoll库通过相关调用通知内核创建一个有N个描述符的事件列表.
然后给描述符设置所关注的事件,并把它添加到内核的事件列表中,在编码中还可通过相关调用对事件列表中的描述符进行
修改和删除.完成设置之后,epoll库就等待内核通知事件发生.某一事件发生后,内核将发生事件的描述符列表上报给epoll库.

由于epoll, kqueue, IOCP每个接口都有自己的特点，程序移植非常困难，于是需要对这些接口进行封装，以让它们易于使用和移植，其中libevent库就是其中之一。跨平台，封装底层平台的调用，提供统一的 API，但底层在不同平台上自动选择合适的调用。

epoll等模型解决了c10k问题, c10m问题的解决思路是减少os层的干预,即减少上下文的切换,尽量在用户态,即协程.

nginx架构三方面内容: nginx服务器的进程, 进程交互,Run-Loop事件处理循环机制
进程分主进程,工作进程,缓存索引重建及管理进程; 进程交互分master-worker交互,worker-worker交互;Run-Loop是处理客户端发
过来的请求,是最复杂的.
nginx采用模块化设计,方便的支持第三方模块,已有大量的第三方模块.但所有的模块都必须预先编译进nginx的二进制可执行文件.
Apache是可以动态添加的.


nginx支持的最大连接数max_clients = worker_processes * worker_connections;
nginx作为反向代理时：max_clients = worker_processes * worker_connections/2
需要与客户端和上游的服务器各建立一个连接,而不是除以4. 部分资料上除以4认为是浏览器每个请求会建立两个连接,但是两次请求也可能不是同时发.
并发数的前提是worker_rlimit_nofile大于等于worker_connections的大小, worker_rlimit_nofile已经覆盖了linux系统的文件描述符的限制.
worker_connections=3是最小设置，设置成1和2分别无法正常启动nginx以及无法处理一个http请求。

nginx作为web服务器静态网站性能很高,但是不能支持php,jsp等动态语言,因此不能独立支持独立站点的建设. 需要结合apache等web服务器
nging做反向代理才可以,即lnamp架构.

在《unix网络编程》中，并发模型有多种，都是短连接的形式，连接处理完之后就关闭。 但已经有reactor雏形了，一个主进程接收，然后分发到进程池。
接收的方式可以用io复用，也可以每个子进程单独进行select，比如nginx的模式，也可以每个线程单独select（memcached ?）
单个epoll和线程池和每个线程一个epoll的讨论
https://www.zhihu.com/question/271561199


如果我们想保证无论多次执行程序都只保证系统内只有一个该程序的进程的话就需要pid文件来控制.
如果不设置pid file,可以起多个后台进程. 如果设置了pid file, 则只有一个进程,而且新起的进程会先杀死之前的进程然后再起.

## nginx长连接
nginx upstream与后端的连接默认为短连接，通过HTTP/1.0向后端发起连接，并把请求的"Connection" header设为"close"。Nginx与前端的连接
默认为长连接，一个用户跟Nginx建立连接之后，通过这个长连接发送多个请求。如果Nginx只是作为reverse proxy的话，可能一个用户连接
就需要多个向后端的短连接。如果后端的服务器（源站或是缓存服务器）处理并发连接能力不强的话，就可能导致瓶颈的出现。

比如前后端分离的架构，一个页面要请求到不同的后端服务，与前端只有一个连接，那请求到不同的服务必然得重新请求，不能复用一个连接。

<Nginx反向代理实现支持长连接详解> https://www.jb51.net/article/117261.htm

## nginx负载均衡
nginx虽有四层负载均衡的功能，但一般应用中用七层负载均衡，四层负载均衡用lvs或F5等实现。

七层负载均衡个就是根据http请求中的url做分发，比如前后端分离的应用。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，
再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。

四层负载均衡是工作在tcp，udp等传输层，需要修改数据包的地址信息(snat, dnat等)转发到应用服务器。y既然四层负载均衡做的主要工作是转发，
那就存在一个转发模式的问题，目前主要有四层转发模式：DR模式、NAT模式、TUNNEL模式、FULLNAT模式。
一般先是四层负载均衡后面挂七层负载均衡再到应用服务器，因为大公司有很多业务，所有业务部署在一个机房，机房统一通过lvs暴露出去，lvs上给不同业务分配不同IP，
请求到了之后根据访问的IP请求到对应的nginx服务器，然后再请求到真实的应用服务器。
也可以开源四层负载均衡后直接挂应用服务器。四层均衡中的nat模式其实就是反向代理，实现客户端访问内网服务器，此时的四层负载均衡服务器就是个网关。

nginx的四层均衡有stream模块实现，在nginx1.9之后加入的，配置跟http模块一样。