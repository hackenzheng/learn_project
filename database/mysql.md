主键和外键：

关系型数据库不能设置两个主键,但可以将两个字段的组合作为一个主键即联合主键.主键是唯一区分,与唯一约束是有区别的,主键一张表只有一个,可以做外键,不能为空，唯一约束可以有多个，主要用来约束字段的唯一性.
外健是关联的数据,联表查询有无外键都可以, update的作为外键的主键的value时或删除主键的记录时,会做关联检查,具体的约束规则可以设置,比如是不允许更新或删除,或者是全部更新或删除,用于保证数据的完整性和一致性,
外键的意义：用于与其他表建立连接，用于预防破坏表之间的链接；防止非法数据插入到外键列，因为要插入的值必须已经是在其他表中的主键出现了才行。
数据库支持事物,支持外键,那么一致性在数据库服务器完成, 如果数据库不支持但又要处理事务就要在在业务代码中完成.
在并发不大压力不大时,可以使用外键,减小开发工作量,很多业务逻辑上的校验不用写代码完成.
但如果互联网行业并发大的时候一般不使用,因为数据库服务器做关联性检查会拖慢数据库的速度.而应用服务器是可以方便扩展的.

创建表的时候很容易字段里面出现空格，建好之后用desc table一下，查看是否有多的空格，不然插入数据会失败。SQL操作时，若字段是关键字，需要单引号转义。

## 索引
索引：b树和b+树都是多路平衡搜索树，b树是非叶子节点也会存储数据，b+树只有最后的叶子节点存储数据，用b+树索引是相对于b树每个节点存储的索引信息会更多，
因为不用存储数据。为了方便批量查询，b+树的叶子节点会通过指针连接起来。

innodb引擎：

    如果给主键设置了索引就用主键创建主键索引，如果没有就默认以rowid创建索引。主键索引是聚簇索引，最后的叶子节点会存储具体的数据。
    其他字段建的索引都是非聚簇索引，叶子节点不存数据，而是指向主键索引的节点(具体就是主键的值)。这样直接从索引取数据而非从磁盘的文件中取数据。　
    比如id是主键，age是普通索引，走非主键age的查询过程是：索引先根据age搜索等于18的索引记录，找到ID=10的记录，然后再到主键索引搜索一次，然后拿出需要查询的数据。
    从普通索引查出主键索引，然后查询出数据的过程叫做回表。由于回表需要多执行一次查询，这也是为什么主键索引要比普通索引要快的原因，所以，我们要尽量使用主键查询。
    
    非主键索引也被称为二级索引，drop主键索引会导致其他索引失效,但drop普通索引不会
    那相当于存储两份数据，占的空间不是很大？
    
    覆盖索引：要查询的字段都建了索引，就叫做“覆盖索引”。这样的话查询的数据直接从索引中取，不需要在走主键索引树。

主键尽量使用自增主键而非UUID：

    使用自增主键时，每次插入一条新记录,都是追加操作,都不涉及到挪动其他记录,也不会触发叶子节点的分裂。而有业务逻辑的字段做主键,则往往不容易保证有序插入,这样写数据成本相对较高。
    除了考虑性能外,我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段,比如字符串类型的身份证号,那应该用身份证号做主键,还是用自增字段做主键呢?
    由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键,那么每个二级索引的叶子节点占用约 20 个字节,而如果用整型做主键,则只要 4 个字节,如果是长整型(bigint)则是 8 个字节。
    显然,主键长度越小,普通索引的叶子节点就越小,普通索引占用的空间也就越小。
    
    有没有什么场景适合用业务字段直接做主键的呢?还是有的。比如,有些业务的场景需求是这样的:
    1. 只有一个索引;
    2. 该索引必须是唯一索引。
    这是典型的 KV 场景。由于没有其他索引,所以也就不用考虑其他索引的叶子节点大小的问题。
    这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则,直接将这个索引设置为主键。
    
    当然在高并发负载时，主键顺序插入可能会造成明显的争用，会导致间隙锁竞争。

模糊查询是否走索引的问题：

    select * from user where name like 'j' 或 'j%' 或 '%j' 或 '%j%';
    1. like 'j' 或 'j%' 可以使用索引，并且快速定位记录，表象就是查询速度很快。
    2. like '%j' 或 '%j%'，只是在二级索引树上遍历查找记录，并不能快速定位（使用了索引，但是扫描了整棵索引树），表象就是查询速度没那么快。
    两者的区别就是“用索引”和“用索引快速定位记录”，两者都用了索引，但是第二种没有发挥索引的优势，建了索引还遍历所有的索引是低效的。

select * from data where a='1' or b = '2'; 查询语句索引匹配情况： 如果建的是a,b联合索引； 如果a，b分别建的独立索引

可以对一个列创建多个相同的索引，没有任何用处，如果有需要移除。mysql的唯一限制和主键限制都是通过索引实现的。
    
    下面这条语句会在id列上创建3个索引
    create table test(id int not null primary key, a int not null, unique(id), index(id));
    
冗余索引: 先创建索引(A,B)，再创建索引(A就是冗余索引。
    
衡量查询开销的三个指标：响应时间，扫描的行数，返回的行数

数据库在更新数据时先更新数据文件在内存的副本，并同时追加到wal(预写日志)做持久化，内存中的数据再统一做持久化。
这样每次更新数据是需要两次写入，但wal日志是追加，属于顺序写而非随机写，速度比直接修改数据文件的内容要快。
完整的更新流程是怎么样的？

innodb是一定会有主键索引的，主键索引属于聚簇索引，所以存储方式是数据行和主键索引一起存储，而不会再单独存储一份数据，
不然数据就存储了两份，浪费空间，而且更新的时候效率很低。所以innodb中，聚簇索引就是表。 
myisam的主键索引的叶子节点存放的是数据对应的行指针，所以是非聚簇索引。 innodb的二级索引存的是主键的值，而myisam的二级索引
跟主键索引一样，存的仍然是行指针。
![](./innodb_index.bmp)


条件in的查询过程，mysql将in()列表中的数据先进行排序，然后通过二分查找的方式判断每个值。比多个or条件的查询速度要快。

关联查询： MySQL认为任何一个查询都是一次关联，比如关联查询A和B，固定表B，从A里面一行行的读取符合条件的，然后从B表中去匹配。
效是比较低的，如果有多层关联查询，先做底层的关联，生成临时表，再对临时表做关联。

## 高性能mysql

<深入理解 MySQL 事务隔离级别和 MVCC 原理>
https://mp.weixin.qq.com/s/Jeg8656gGtkPteYWrG5_Nw

innodb默认隔离级别是可重复读，即一个事务当中任何时刻看到的同一行的内容是一样的，但是如果范围查找比如limit得到的结果则是可以变的，
即幻行读取(幻读)。意思就是这种隔离级别不会update已有数据，但是可以新增数据。 用串行化的隔离级别是可以的解决的，但是并发性能太低。
innodb和xtradb存储引擎通过间隙锁的方式解决幻读问题，即对索引的区间加锁。 又提到是多版本并发控制(mvcc)解决？ 

mvcc,在每一行数据增加两个隐藏字段，其中一个就是版本。是行级锁的变种，但在很多情况下避免了加锁操作。

在同一个数据库实例中不同的表使用不同的存储引擎是可以的。 但在同一个事务中，使用到不同的存储引擎是不可靠的，如果中间有一个存储引擎不支持事务就无法回滚。

避免null的值，因为null使得索引，索引统计和值的比较都更复杂，需要占据更多的空间。

数据库支持同时提交多个事务，因为要考虑并发性能，如果这些事务之间不会访问相同的数据，那么只要解决单个事务的问题。
如果访问到相同的数据就有可能出现冲突。数据库设置了一定机制避免冲突，一个事务与其他事务隔离的程度称为隔离级别，隔离级别越高, 数据一致性就越好, 但并发性越弱

冲突可能产生的问题有：脏读，不可重复读，幻读，丢失更新。 SQL标准定义了4个隔离级别：读未提交数据，读已提交数据，可重读，可串行化。
参考：http://www.cnblogs.com/luojianqun/p/6524166.html


隔离级别的实现，通过锁来解决，具体的方法： https://www.zhihu.com/question/51678508


## 实战mysql
   查询缓存往往弊大于利,查询缓存的失效非常频繁,只要有对一个表的更新,这个表上所有的查询缓存都会被清空。
   除非你的业务就是有一张静态表,很长时间才会更新一次。比如,一个系统配置表,那这张表上的查询才适合使用查询缓存。
   MySQL 8.0 版本直接将查询缓存的整块功能删掉了。
   
   redo log(重做日志，属innodb引擎)和binlog(归档日志，server层)，而redo log用的是wal(预写日志)技术，先将日志写到缓存，然后再刷到磁盘。
   redo log 是固定大小的,比如可以配置为一组4个文件,每个文件的大小是1GB，是循环更新的。

## Ubuntu 安装mysql
   从官网下载社区版编译好的二进制安装包，目前已到8.0版本。 解压到/usr/local/bin或其他目录下，设置好环境变量。
   
       apt-get install libaio1 安装动态库
       bin/mysqld --initialize --user=mysql  初始化data目录
       bin/mysqld_safe --user=mysql &或bin/mysqld 启动，会给root用户初始化一个随机密码
       mysql -u root -p  连接数据库
       alter user 'root'@'localhost' identified by 'youpassword';  修改密码
       flush privileges;    刷新权限
