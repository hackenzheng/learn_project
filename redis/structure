## 数据结构
   基础的数据结构sds,双向链表,字典(两个hash表),ziplist, skiplist,整数集合(整数数组)，在此基础上再形成对象。
   在redis里面，每个key,每个val都会再抽象成redis object,而非直接用基础的数据结构。
   
   skiplist跳表，底层就是链表，链表的每个元素有一个level数组，数组中每个元素是指向skiplistnode的指针。跳表在redis里面
   只作为zset和内部数据结构。 
   
   zset的实现方式有两种，数据量小的时候是ziplist,大的时候是skiplist+dict，用dict直接保存元素和score的关系，这样根据
   元素获取score的复杂度是o(1)，非常高效。 并且dict和skiplist是共享元素对象的和分数，并不会多耗费很多空间。共享的方式是，
   元素本身robj对象，skiplistNode中的指针robj *obj;直接指向它，dict中的key对象也直接指向它。而分数是绑定在skiplistNode上的，
   dict中在指向这个分数。
   
   zset中第一个节点的rank是1而不是0，加入zset1里有1,one; 2 two; 3 three; 三个元素，zrank zset1 one返回的是1而不是0.
   但是zrange的计数却是从0开始。zrange zset1 start stop的时间复杂度是log(n) + stop-start.实现过程是先根据rank start找到
   对应的元素的位置，然后再往前走。根据rank找元素的时间复杂度平均是log(n),最差是n，过程是从第一个节点的最上层开始，直接根据span判断。
   根据分值和成员对象查找在跳跃表中的排位的复杂度平均log(n),最差是n，但是根据score做比较。 zset在数据量小于512且对象不大时用的是ziplist,
   这个时候只能从头开始遍历，复杂度是stop.
   
   ziplist相比于链表的优势，除了头部和尾部几个额外的空间外，不需要给每个元素在分配指针变量，另外是连续分配的内存，不会造成内存碎片化。
   在redis4.0的版本后面又增加了quiclist，结合ziplist和链表，即用链表的形式将每个小的ziplist连起来。

   dict对象能够序列化成字符串，所以应用到底时候什么情况下用string什么情况下用dict要看场景。大体来说如果大部分的访问是要访问所有的filed,
   就用string，如果大部分的时候只需要访问少数的filed就用dict，访问效率更高。  更新多也要看场景，如果更新很频繁，但每次都要把所有的field修改，
   直接用string覆盖也比较快。 json的序列化和反序列化的影响有，但是不大。
   https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency
   
   redis中使用共享对象来节约存储空间，每个对象都有refcount,当为0时会启动内存回收机制。共享对象用到的地方有：
   全局的共享对象，比如返回值'OK'; zset中skiplist和dict的共享元素。
   
   Redis在3.0引入EMBSTR编码，这种编码和RAW编码都是用sdshdr简单动态字符串结构来表示。RAW编码会调用两次内存分配函数来分别
   创建redisObject和sdshdr结构，而EMBSTR只调用一次内存分配函数来分配一块连续的空间保存数据，比起RAW编码的字符串更能节省内存，
   以及能提升获取数据的速度。EMBSTR是不可修改的，当对EMBSTR编码的字符串执行任何修改命令，总会先将其转换成RAW编码再进行修改；
   代码在object.c/createEmbeddedStringObject()
   
       robj *createEmbeddedStringObject(char *ptr, size_t len) {
           robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1);    //虽是robj类型，但指向的内存是可以大于这个的
           struct sdshdr *sh = (void*)(o+1);    //o+1移动一个robj的长度，这样就到了sdshdr的开头
       
           o->type = REDIS_STRING;
           o->encoding = REDIS_ENCODING_EMBSTR;
           o->ptr = sh+1;
           o->refcount = 1;
           o->lru = LRU_CLOCK();
       
           sh->len = len;
           sh->free = 0;
           if (ptr) {
               memcpy(sh->buf,ptr,len);
               sh->buf[len] = '\0';
           } else {
               memset(sh->buf,0,len+1);
           }
           return o;
       }
   
   1. redis hash表的初始化:tabel初始化为NULL,其他变量初始化为0.也就是创建的时候是默认没有元素，然后一个个添加。
   在hasttb的基础上进一步封装得到dict,每个dict有两个hashtb,用于rehash扩容或缩容