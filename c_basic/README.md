该目录下是c/c++的基本知识点，每个文件都能单独编译

指针:保存的是另一个变量的地址，通过指针可直接修改变量的值。二级指针也是指针，只不过对应的变量是另外一个指针变量。
定义指针p,无论是一级还是二级，支持的操作有p(查看或修改p保存的地址),*p(p所指向的变量的值),&p(p本身的地址)。
如果用普通变量地地址初始化二级指针会编译不通过。  一定避免指针未初始化就赋值。不能用多重指针表示多维数组。

void型指针可以指向任意类型的数据，可以将任意类型的指针对void指针赋值，指针之所以要对应数据类型，是因为指针在进行P++等算数操作时，要确定一次移动几个字节。  
数据类型转换，较低类型转换为较高类型，只形式上有所改变，不影响数据的实质内容；较高类型转换为较低类型则可能有数据丢失；
有符号型和无符号型相互转换往往因正负号发生数值变化，两者转换后二进制是一样，但表示的数不一样，两者做运算时有符号转成无符号型。 

如果非得用指针作为参数去申请内存，应该用二级指针。
```$xslt
void GetMemory(char **p, int num){
   *p = (char *)malloc(sizeof(char)*num);
}
```
一般是将分配的内存首地址作为参数返回
```$xslt
char * GetMemory(int num){
   char *p = (char *)malloc(sizeof(char)*num);
   return p;
}
```


redis的dictht的实现用的二级指针定义了底层的数组


用free释放内存后没有将指针设置为NULL将导致产生指向 “垃圾”内存的野指针。free函数可以把内存释放掉，但是并没有把指针本身干掉，
指针变量p还可以用并指向之前的内存，还能操作原来的数据，导致冲突，用代码模拟一下

数组每个元素类型相同所以可以通过下标访问。结构体中每个成员长度不同，所以不能用下标只能通过名字访问。结构体名也不像数组名那样能被指针替换。


typedef int a[10]这样声明之后，相当于类型a是int[10]这样的规格 

C++中const变量在编译的时候已经确定了，而C中的const变量可以在运行时改变后再次读取。当然如果一个形参不是按照引用或者指针调用，则加const没什么意义，
因为函数中使用的形参只是接收参数的副本。 若参数作输出用，都不能加const修饰，否则该参数将失去输出功能。 

    1）const在类型前面 
    
    const int nValue；           //nValue是const 
    
    const char *pContent;        //*pContent是const, pContent可变 
    
    const char* const pContent;   //pContent和*pContent都是const 
    
    2）const在类型后面，与上面的声明对等 
    
    int const nValue;             //nValue是const 
    
    char const * pContent;        //*pContent是const, pContent可变 
    
    char* const pContent;         //pContent是const,*pContent可变 
    
    char const* const pContent;    //pContent和*pContent都是const  
    

头文件和定义文件：

    （1）要不要在a.c里包含a.h； 
    
    （2）要用到的外部.h文件放在a.h里还是a.c里 
    
    （3）要不要把所有的.h文件放在一个.h文件里； 
    
    （4）两个.h文件相互include; 
    
    （5）头文件"a.h"声明"b.cpp"中实现的函数，在"c.cpp"中使用"a.h"中声明的函数，通常都是在"c.cpp"中使用#include "a.h",
    那么c.cpp是怎样找到b.cpp中的实现呢？  即对应的.c和.h文件不同名，编译器怎么办
    
    答：（1）不一定，若a.c里的函数需要调用a.c里的其它函数，则include同名的.h，这样就不用为声明和调用顺序发愁了。 
    
    （2）#include尽量写到.c文件里。如果你在a.h头文件中include了“stdio.h”，“iostream”，……一大堆那么你的a.cpp源文件只要include你的a.h，
    就相当于include了“stdio.h”，“iostream”，……一大堆，但是当其他文件include你的a.h的同时也就包含了“stdio.h”，“iostream”，……一大堆，
    增加了其他编译单元的代码量，编译起来更慢。且有时xx.c文件不一定include同名.h文件。 
    
    （3）这样写虽然简单美观，但会include很多不必要的头文件，增加了编译单元的代码量，编译速度慢，而且也不清楚彼此的调用关系。 
    
    （4）编译不会报错，因为都用了#pragma once。 
    
    （5）#include预处理就是完成了一个"复制并插入代码"的工作。程序编译的时候，不会去找b.cpp文件中的函数实现，
    只有在link的时候才进行这个工作。我们在b.cpp或c.cpp中用#include "a.h"实际上是引入相关声明，使得编译可以通过，
    程序并不关心实现是在哪里，是怎么实现的。源文件编译后成生了目标文件（.o或.obj文件），目标文件中，
    这些函数和变量就视作一个个符号。在link的时候，需要在makefile里面说明需要连接哪个.o或.obj文件（在这里是b.cpp生成的.o或.obj文件），
    此时，连接器会去这个.o或.obj文件中找在b.cpp中实现的函数，再把他们build到makefile中指定的那个可以执行文件中。 

  
指向数组的指针叫数组指针（落点是指针）;指针数组本质是数组（落点是数组），数组元素是指针。声明数组指针int (*a)[4],二维数组int num[2][4]，一维数组data[4];初始化可以为a=num、a=&num[1]、a=&data，访问其中的元素用（*a）[i]或者a[0][i]，表示该数组第i个元素。一维数组多用指针变量表示，数组指针常用于指向多维数组。比如b[3][4];那么a= b后，*a, *(a+1), *(a+2)分别是b[0], b[1], b[2]。利用a++可以遍历这些长度为10的数组。二维数组名是一个数组指针，而不是二级指针，char *p[n],这里p才是二级指针。 数组做形参退化为指针，一维的退化为指向变量的指针，二维的退化为指向一维数组的指针，以此类推。  

数组名num表示第一个元素的地址，一维数组元素是单个变量，二维数组元素是一个一维数组，&num表示数组的首地址，是整个数组的首地址，虽然两者数值上相同，但表达的意义不同，在给指针数组赋值的时候体现出来；&num+1是在num的基础上加上整个数组占的空间大小；Num+1是加一行元素占的空间，一维数组是加一个元素占的空间。   未初始化的指针随机指向一个地址，有可能是系统中重要的内存位置。全局变量初始化清零是因为所有的全局变量在一个区域，对这块内存统一做一次清零就好，栈上的局部变量就不同了，如果要做清零意味着每次函数调用后都要插入一次清零，增加函数调用成本。 

  